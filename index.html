<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="./css/bootstrap.min.css" rel="stylesheet">
    <script src="./js/bootstrap.min.js"></script>
    <script src="./lib/vue.min.js"></script>

    <title>ひとりポーカー</title>
</head>
<body>
<div id="app-porker">
    <button class="btn btn-info m-1" v-on:click="sort">手札の並び替え</button>
    <button class="btn btn-secondary m-1" v-on:click="checkall">全てを選択（トグル）</button>
    <div>
        <div v-for="(hand, index) in hands" style="float: left; padding: 10px">
            <input type="checkbox" id="hand" v-model="checkedValues"
                :value="index" :id="'hand'+index">
            <label style="width: 120px; height: 200px; background-color: lemonchiffon; border-radius: 7px"
                :style="{ border: checkedValues.includes(index)?
                '2px solid blue' : '2px solid gray' }" :for="'hand' + index" >
                {{ stringHand(hand) }}
            </label>
        </div>
    </div>
    
    <div style="clear: both;">
        <hr>
        <button class="btn btn-primary m-1" @click="redraw">選択した手札を交換</button>
        <hr>
        <p> 評価: {{ evaluationHands(hands) }}</p>
        <p> 手番の回数: {{ changeCount }}</p>
        <p> 山札の枚数: {{ deck.length }}</p>
        <hr>
        <button class="btn btn-warning m-1" @click="cheetChange"> チート </button>
        <div class=" m-5" v-if="cheet">
            <button class="btn btn-primary m-1" @click="remake">選択した手札をランダムに作り直す</button>
            <hr>
            <button class="btn btn-warning m-1" v-on:click="straight">ランダムなストレート</button>
            <button class="btn btn-warning m-1" v-on:click="flash">ランダムなフラッシュ</button>
            <button class="btn btn-warning m-1" v-on:click="sflash">ランダムなストレートフラッシュ</button>
            <button class="btn btn-warning m-1" v-on:click="rsflash">ランダムなロイヤルストレートフラッシュ</button>
            <hr>
            <p> 山札 : {{ deck }} </p>
            <hr>
            <button class="btn btn-danger" @click="debugChange"> debugや実験 </button>
            <div v-if="debug">
                <p> 手札 : {{ printHands(hands) }} </p>
                <p> Checked Values: {{ checkedValues | json }} </p>
                <p> 0から12までの乱数: {{ Math.floor(Math.random() * 13) }} </p>
                <p> makeCard(): {{ makeCard() }}</p>
                <p> makeCard('♠', 14): {{ makeCard('♠', '14') }}</p>
                <p> evaluationHands(): {{ evaluationHands(hands) }}</p>
                <p> deduplication(hands): {{ deduplication(hands) }}</p>
                <p> ソート後の手札 : {{ printHands(sortHands(hands.concat())) }} </p>
                <p> ストレートかどうか：{{ isStraight(hands)? 'ストレート' : '違う' }}</p>
                <p> sameNumCount(hands)：{{ sameNumCount(hands) }} </p>
            </div>
        </div>
    </div>
</div>

<script>
    const marks = ['♠', '♡', '◇', '♣',];
    const num_marks = ['J', 'Q', 'K', 'A'];
    
    new Vue({
        el: '#app-porker',
        data:
        {
            hands:[
            ],
            deck:[],
            checkedValues: [],
            changeCount: 0,
            cheet: false,
            debug: false,
        },

        created: function()
        {
            // 山札を初期化する
            initializeDeck(this.deck);

            this.hands.push(drawCard(this.deck));
            this.hands.push(drawCard(this.deck));
            this.hands.push(drawCard(this.deck));
            this.hands.push(drawCard(this.deck));
            this.hands.push(drawCard(this.deck));
        },

        methods:
        {
            cheetChange: function(value)
            {
                this.cheet = !this.cheet
            },
            debugChange: function(value)
            {
                this.debug = !this.debug
            },
            // デッキのカードと手札を交換する
            redraw: function()
            {
                let len = this.checkedValues.length;
                if (false === (0 === len)) {
                    this.changeCount += 1;
                }
                for (var i=0; i < len; i++) {
                    let index = this.checkedValues[i];
                    this.$set(this.hands, index, drawCard(this.deck));
                }
                emptyArray(this.checkedValues);
            },

            // 選択した手札をランダムなカードに作り変える
            remake: function()
            {
                let len = this.checkedValues.length;
                for (var i=0; i < len; i++) {
                    let index = this.checkedValues[i];
                    this.$set(this.hands, index, makeCard());
                }
                emptyArray(this.checkedValues);
                this.changeCount += 1;
            },

            // すべての選択する
            checkall: function()
            {
                if ( 5 === this.checkedValues.length) {
                    for (let i=0; i<5; i++) {
                        this.checkedValues.pop();
                    }
                } else {
                    for (let i=0; i<5; i++) {
                        this.checkedValues.push(i);
                    }
                }
            },

            // 以下チート
            // 手札を昇順に並べ替える
            sort: function()
            {
                sortHands(this.hands);
                emptyArray(this.checkedValues);
                this.$set(this.hands);
            },

            // ランダムなロイヤルストレートフラッシュ
            rsflash: function()
            {
                let mark = marks[Math.floor(Math.random() * 4)];
                for (let i=0; i<5; i++) {
                    this.hands[i] = makeCard(mark, 10 + i);
                }
                this.changeCount += 1;
                this.$set(this.hands);
            },

            // ランダムなストレートフラッシュ
            sflash: function()
            {
                let mark = marks[Math.floor(Math.random() * 4)];
                let num = Math.floor(Math.random() * 10);
                for (let i=0; i<5; i++) {
                    this.hands[i] = makeCard(mark, num + i);
                }
                this.changeCount += 1;
                this.$set(this.hands);
            },

            // ランダムなストレート
            straight: function()
            {
                let mark;
                let num = Math.floor(Math.random() * 10);
                for (let i=0; i<5; i++) {
                    mark = marks[Math.floor(Math.random() * 4)];
                    this.hands[i] = makeCard(mark, num + i);
                }
                this.changeCount += 1;
                this.$set(this.hands);
            },

            // ランダムなフラッシュ
            flash: function()
            {
                let mark = marks[Math.floor(Math.random() * 4)];
                let num;
                for (let i=0; i<5; i++) {
                    num = Math.floor(Math.random() * 13);
                    this.hands[i] = makeCard(mark, );
                }
                this.changeCount += 1;
                this.$set(this.hands);
            },
        },
    })

    /**
     * カードを生成
     * 
     * *説明* 引数がないと、ランダム
     *        ジョーカーは存在しないことになっている
     * 
     * @param マークと数値を指定
     * @return カードのマークと数値を返す
     */
    function makeCard (mark, num)
    {
        let return_string = {mark, num};

        if (mark === undefined && num === undefined) {
            return_string.mark = marks[Math.floor(Math.random() * marks.length)];
            return_string.num = Math.floor(Math.random() * 13)+2;
        } else {
            return_string = {mark: mark, num: num};
        }

        return return_string;
    }

    /**
     * デッキからカードを引く
     * 
     * *説明* 引数がないと、ランダム
     *        ジョーカーは存在しないことになっている
     * 
     * @param array デッキ
     * @param int マークを番号を指定
     * @param int 数値を指定
     * @return カードのマークと数値を返す
     */
    function drawCard (deck, mark, num)
    {
        let return_card = undefined;
        let random_draw_num = Math.floor(Math.random() * deck.length);

        if (mark === undefined && num === undefined) {
            return_card = deck[random_draw_num];
            deck.splice(random_draw_num, 1);
            return return_card;
        } else {
            let isExit = deck.indexOf(makeCard(marks[mark], num));
            if (isExit) {
                let index = isExit;
                return_card = makeCard(marks[mark], num);
                deck.splice(index, 1);
                return return_card;
            } else {
                return_card = undefined;
                return return_card;
            }
        }
    }

    /**
     * 配列を空にする
     * @param array
     */
    function emptyArray(array)
    {
        let len = array.length;
        for (let i=0; i<len; i++) {
            array.pop();
        }
    }

    /**
     * 手札を評価する
     * *説明*
     * 
     * @param 1-5
     * @return 揃った役の名前を表示
     */
    function evaluationHands(hands)
    {
        let len = hands.length - 1;
        // 手札が5枚なければ役は出来ない
        if (false === (5 === hands.length)) {
            return "役なし";
        }
        // 重複を判定する
        let d = deduplication(hands);
        
        // ストレートかつフラッシュのと き
        if (1 === d.marks) {
            if (false === (0 === isStraight(hands))) {
                if (14 === sortHands(hands.concat())[len].num) {
                    return "ロイヤルストレートフラッシュ";
                } else {
                    return "ストレート・フラッシュ";
                }
            }
        }
        // 重複しない数字が２つならフォア・カードかフルハウス
        if (2 === d.nums) {
            if (4 === sameNumCount(hands)) {
                return "フォア・カード"
            } else {
                return "フルハウス"
            }
        }
        // 重複しないマークがひとつならフラッシュ
        if (1 === d.marks) { 
            return "フラッシュ";
        }
        if (false === (0 === isStraight(hands))) {
            return "ストレート";
        }
        // 重複しない数字が３つならスリーカードかツウ・ペア
        if (3 === d.nums) {
            if (3 === sameNumCount(hands)) {
                return "スリー・カード"
            } else {
                return "ツウ・ペア"
            }
        }
        // 重複しない数字が１つならワンペア
        if (4 === d.nums) {
            return "ワンペア";
        }
        return "役なし";
    }

    /**
     * 手札から数字とマークの重複を排除した個数
     * 
     * @param array hands
     * @return object
     */
    function deduplication(hands)
    {
        let _nums = [];
        let _marks = [];
        let len = hands.length;
        for (let i=0; i<len; i++) {
            _nums.push(hands[i].num);
            _marks.push(hands[i].mark);
        }
        // 重複を排除
        _nums = Array.from(new Set(_nums));
        _marks = Array.from(new Set(_marks));

        return {marks: _marks.length, nums: _nums.length};
    }

    /**
     *  ストレートかどうかを判定し、
     *  ストレートであればその強さを返す
     *  
     *  @param array hands
     *  @return int
     */
    function isStraight(hands)
    {
        let len = hands.length;
        let hands_sorted = sortHands(hands.concat());
        
        for (let i=1; i<len; i++) {
            if (false === (hands_sorted[i-1].num + 1 === hands_sorted[i].num)) {
                // 一つ前のカードよりも一つだけ増えていなければ、ストレートでない
                return 0;
            }
        }
        // 最後まで一つずつ増えていれば、ストレートなので一番高い数字を返す
        return hands_sorted[len-1].num;
    }

    /** 
     * カードを数字順に
     * 
     * *説明* 単純なソートでlog(n^2)
     * @param array hands
     * @return array hands
     */
    function sortHands(hands)
    {
        let len = hands.length;
        let hand_tmp;

        // 単純なソート 
        for (var i=0; i<len-1; i++) {
            for (var j=i+1; j<len; j++) {
                // 数字を比較
                if (true === (hands[i].num > hands[j].num)) {
                    hand_tmp = hands[j];
                    hands[j] = hands[i];
                    hands[i] = hand_tmp;
                }
                // 数字が同じだったらマークを比較してソート（弱いほど左）
                if (hands[i].num === hands[j].num) {
                    if (markPriority(hands[j] > markPriority(hands[i]))) {
                    hand_tmp = hands[j];
                    hands[j] = hands[i];
                    hands[i] = hand_tmp;
                    }
                }
            }
        }
        return hands;
    }

    /**
     * ストレートかどうかを判定する
     * 
     */
    function stringHand(hand)
    {
        if (10 < hand.num) {
            return hand.mark+num_marks[hand.num - 11];
        } else {
            return hand.mark+hand.num;
        }
    }

    /** 
     * カードを文字列で表示
     * 
     * @param array hands
     * @return array
     */
    function printHands(hands)
    {
        len = hands.length;
        outStr = '';
        for (var i=0; i<len; i++) {
            outStr += stringHand(hands[i])+', ';
        }
        return outStr;
    }

    /**
     * マークの優先度を返す
     * 
     * @param obj hand
     * @return int
     */
    function markPriority(hand) {
        return marks.indexOf(hand.mark);
    }

    /**
     * 最大の同じ数字が何枚かを数える
     * 
     * *例* スリーカードかフルハウスのときは3を返す
     * @param array hands
     * @return int
     */
    function sameNumCount(hands)
    {
        let len = hands.length;
        let hands_sorted = sortHands(hands.concat());
        let count_max = 1;
        let count_smaller = 1;

        
        for (var i=1; i<len; i++) {
            if (hands_sorted[i-1].num === hands_sorted[i].num) {
                // 一つ前のカードよりと同じ数字なら数字を増やす
                count_max += 1;
            } else {
                // 別な数字になったとき
                if (count_max > count_smaller ) {
                    count_smaller = count_max
                }
                count_max = 1;
            }
        }
        if (count_smaller > count_max) {
            count_max = count_smaller;
        }
        return count_max;
    }

    /**
     * 山札を初期化する
     * @param array
     */
    function initializeDeck(deck)
    {
        for (let i=0; i<marks.length; i++) {
            for (let j=2; j<15; j++) {
                deck.push(makeCard(marks[i], j))
            }
        }
    }
</script>
</body>
</html>