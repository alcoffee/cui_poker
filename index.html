<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="./css/bootstrap.min.css" rel="stylesheet">
    <script src="./js/bootstrap.min.js"></script>
    <script src="./lib/vue.min.js"></script>

    <title>ひとりポーカー</title>
</head>
<body>
<div id="app-porker">
    <div>
        <div v-for="(hand, index) in hands" style="float: left; padding: 10px">
            <input type="checkbox" id="hand" v-model="checkedValues"
                :value="index" :id="'hand'+index">
            <label style="width: 120px; height: 200px; background-color: lemonchiffon; border-radius: 7px"
                :style="{ border: checkedValues.includes(index)?
                '2px solid blue' : '2px solid gray' }" :for="'hand' + index" >
                {{ stringHand(hand) }}
            </label>
        </div>
    </div>
    
    <div style="clear: both;">
        <p> 評価: {{ evaluationHands(hands) }}</p>
        <p> 手番の回数: {{ changeCount }}</p>
        <p> 引き直しの枚数: {{ changeHandCount }}</p>
        <button class="btn btn-primary" @click="reload">選択した手札を交換・パス</button>
        <!-- <button class="button" @click="checkedReset">ボタン</button> -->
        <hr>
        <button class="btn btn-primary m-1" v-on:click="sort">手札の並び替え</button>
        <button class="btn btn-primary m-1" v-on:click="checkall">全てを選択トグル</button>
        <hr>
        <button class="btn btn-danger" @click="cheetChange"> チート </button>
        <div class=" m-5" v-if="cheet">
            <button class="btn btn-primary m-1" v-on:click="straight">ランダムなストレート</button>
            <button class="btn btn-primary m-1" v-on:click="flash">ランダムなフラッシュ</button>
            <button class="btn btn-primary m-1" v-on:click="sflash">ランダムなストレートフラッシュ</button>
            <button class="btn btn-primary m-1" v-on:click="rsflash">ランダムなロイヤルストレートフラッシュ</button>
            <hr>
            <button class="btn btn-danger" @click="debugChange"> debugや実験 </button>
            <div v-if="debug">
                <p> 手札 : {{ printHands(hands) }} </p>
                <p> Checked Values: {{ checkedValues | json }} </p>
                <p> 0から12までの乱数: {{ Math.floor(Math.random() * 13) }} </p>
                <p> makeCard(): {{ makeCard() }}</p>
                <p> makeCard('♠', 14): {{ makeCard('♠', '14') }}</p>
                <p> evaluationHands(): {{ evaluationHands(hands) }}</p>
                <p> deduplication(hands): {{ deduplication(hands) }}</p>
                <p> ソート後の手札 : {{ printHands(handsSort(hands.concat())) }} </p>
                <p> ストレートかどうか：{{ isStraight(hands)? 'ストレート' : '違う' }}</p>
                <p> sameNumCount(hands)：{{ sameNumCount(hands) }} </p>
            </div>
        </div>
    </div>
</div>

<script>
    const marks = ['♠', '♡', '◇', '♣',];
    const num_marks = ['J', 'Q', 'K', 'A'];
    const max_num = 13;

    new Vue({
        el: '#app-porker',
        data:
        {
            hands:[
            makeCard(),
            makeCard(),
            makeCard(),
            makeCard(),
            makeCard(),
            ],
            checkedValues: [],
            changeCount: 0,
            changeHandCount: 0,
            cheet: false,
            debug: false,
            view: [0, 1,],
        },
        methods:
        {
            cheetChange: function(value)
            {
                this.cheet = !this.cheet
            },
            debugChange: function(value)
            {
                this.debug = !this.debug
            },
            /**
             * 引き直し
             */
            reload: function()
            {
                let len = this.checkedValues.length-1;
                for (var i=0; i <= len; i++) {
                    let index = this.checkedValues[i];
                    this.$set(this.hands, index, makeCard());
                    this.changeHandCount += 1;
                }
                emptyArray(this.checkedValues);
                this.changeCount += 1;
            },
            // すべての選択する
            checkall: function()
            {
                if ( 5 === this.checkedValues.length) {
                    for (let i=0; i<5; i++) {
                        this.checkedValues.pop();
                    }
                } else {
                    for (let i=0; i<5; i++) {
                        this.checkedValues.push(i);
                    }
                }
            },
            // 以下チート
            // 手札を昇順に並べ替える
            sort: function()
            {
                handsSort(this.hands);
                emptyArray(this.checkedValues);
                this.$set(this.hands);
            },
            // ランダムなロイヤルストレートフラッシュ
            rsflash: function()
            {
                let mark = marks[Math.floor(Math.random() * 4)];
                for (let i=0; i<5; i++) {
                    this.hands[i] = makeCard(mark, 10 + i);
                }
                this.changeHandCount += 5;
                this.changeCount += 1;
                this.$set(this.hands);
            },
            // ランダムなストレートフラッシュ
            sflash: function()
            {
                let mark = marks[Math.floor(Math.random() * 4)];
                let num = Math.floor(Math.random() * (max_num-2));
                for (let i=0; i<5; i++) {
                    this.hands[i] = makeCard(mark, num + i);
                }
                this.changeHandCount += 5;
                this.changeCount += 1;
                this.$set(this.hands);
            },
            // ランダムなストレート
            straight: function()
            {
                let num = Math.floor(Math.random() * (max_num-4));
                for (let i=0; i<5; i++) {
                    this.hands[i] = makeCard(marks[Math.floor(Math.random() * 4)], num + i);
                }
                this.changeHandCount += 5;
                this.changeCount += 1;
                this.$set(this.hands);
            },
            // ランダムなフラッシュ
            flash: function()
            {
                let mark = marks[Math.floor(Math.random() * 4)];
                for (let i=0; i<5; i++) {
                    this.hands[i] = makeCard(mark, Math.floor(Math.random() * (max_num)));
                }
                this.changeHandCount += 5;
                this.changeCount += 1;
                this.$set(this.hands);
            },
        }
    })

    /**
     * カードを生成
     * 
     * *説明* 引数がないと、ランダム
     *        ジョーカーは存在しないことになっている
     * 
     * @param マークと数値を指定
     * @return カードのマークと数値を返す
     */
    function makeCard (mark, num)
    {
        let return_string = {mark, num};

        if (mark === undefined && num === undefined) {
            return_string.mark = marks[Math.floor(Math.random() * marks.length)];
            return_string.num = Math.floor(Math.random() * max_num)+2;
        } else {
            return_string = {mark: mark, num: num};
        }

        return return_string;
    }
    /**
     * 配列を空にする
     * @param array
     */
    function emptyArray(array)
    {
        let len = array.length - 1;
        for (let i=0; i<=len; i++) {
            array.pop();
        }
    }

    /**
     * 手札を評価する
     * *説明*
     * 
     * @param 1-5
     * @return 揃った役の名前を表示
     */
    function evaluationHands(hands)
    {
        let len = hands.length - 1;
        // 手札が5枚なければ役は出来ない
        if (false === (5 === hands.length)) {
            return "役なし";
        }
        // 重複を判定する
        let d = deduplication(hands);
        
        // ストレートかつフラッシュのと き
        if (1 === d.marks) {
            if (false === (0 === isStraight(hands))) {
                if (14 === handsSort(hands.concat())[len].num) {
                    return "ロイヤルストレートフラッシュ";
                } else {
                    return "ストレート・フラッシュ";
                }
            }
        }
        // 重複しない数字が２つならフォア・カードかフルハウス
        if (2 === d.nums) {
            if (4 === sameNumCount(hands)) {
                return "フォア・カード"
            } else {
                return "フルハウス"
            }
        }
        // 重複しないマークがひとつならフラッシュ
        if (1 === d.marks) { 
            return "フラッシュ";
        }
        if (false === (0 === isStraight(hands))) {
            return "ストレート";
        }
        // 重複しない数字が３つならスリーカードかツウ・ペア
        if (3 === d.nums) {
            if (3 === sameNumCount(hands)) {
                return "スリー・カード"
            } else {
                return "ツウ・ペア"
            }
        }
        // 重複しない数字が１つならワンペア
        if (4 === d.nums) {
            return "ワンペア";
        }
        return "役なし";
    }

    /**
     * 手札から数字とマークの重複を排除した個数
     * 
     * @param array hands
     * @return object
     */
    function deduplication(hands)
    {
        let _nums = [];
        let _marks = [];
        let len = hands.length;
        for (let i=0; i<len; i++) {
            _nums.push(hands[i].num);
            _marks.push(hands[i].mark);
        }
        // 重複を排除
        _nums = Array.from(new Set(_nums));
        _marks = Array.from(new Set(_marks));

        return {marks: _marks.length, nums: _nums.length};
    }

    /**
     *  ストレートかどうかを判定し、
     *  ストレートであればその強さを返す
     *  
     *  @param array hands
     *  @return int
     */
    function isStraight(hands)
    {
        let len = hands.length - 1;
        let hands_sorted = handsSort(hands.concat());
        
        for (let i=1; i <=len; i++) {
            if (false === (hands_sorted[i-1].num + 1 === hands_sorted[i].num)) {
                // 一つ前のカードよりも一つだけ増えていなければ、ストレートでない
                return 0;
            }
        }
        // 最後まで一つずつ増えていれば、ストレートなので一番高い数字を返す
        return hands_sorted[len].num;
    }

    /** 
     * カードを数字順に
     * 
     * *説明* 単純なソートでlog(n^2)
     * @param array hands
     * @return array hands
     */
    function handsSort(hands)
    {
        let len = hands.length - 1;
        let hand_tmp;

        // 単純なソート 
        for (var i=0; i<=len-1; i++) {
            for (var j=i+1; j<=len; j++) {
                // 数字を比較
                if (true === (hands[i].num > hands[j].num)) {
                    hand_tmp = hands[j];
                    hands[j] = hands[i];
                    hands[i] = hand_tmp;
                }
                // 数字が同じだったらマークを比較してソート（弱いほど左）
                if (hands[i].num === hands[j].num) {
                    if (markPriority(hands[j] > markPriority(hands[i]))) {
                    hand_tmp = hands[j];
                    hands[j] = hands[i];
                    hands[i] = hand_tmp;
                    }
                }
            }
        }
        return hands;
    }

    /**
     * ストレートかどうかを判定する
     * 
     */
    function stringHand(hand)
    {
        if (10 < hand.num) {
            return hand.mark+num_marks[hand.num - 11];
        } else {
            return hand.mark+hand.num;
        }
    }

    /** 
     * カードを文字列で表示
     * 
     * @param array hands
     * @return array
     */
    function printHands(hands)
    {
        len = hands.length - 1;
        outStr = '';
        for (var i=0; i<=len; i++) {
            outStr += stringHand(hands[i])+', ';
        }
        return outStr;
    }

    /**
     * マークの優先度を返す
     * 
     * @param obj hand
     * @return int
     */
    function markPriority(hand) {
        return marks.indexOf(hand.mark);
    }

    /**
     * 最大の同じ数字が何枚かを数える
     * 
     * *例* スリーカードかフルハウスのときは3を返す
     * @param array hands
     * @return int
     */
    function sameNumCount(hands)
    {
        let len = hands.length - 1;
        let hands_sorted = handsSort(hands.concat());
        let count_max = 1;
        let count_smaller = 1;

        
        for (var i=1; i<=len; i++) {
            if (hands_sorted[i-1].num === hands_sorted[i].num) {
                // 一つ前のカードよりと同じ数字なら数字を増やす
                count_max += 1;
            } else {
                // 別な数字になったとき
                if (count_max > count_smaller ) {
                    count_smaller = count_max
                }
                count_max = 1;
            }
        }
        if (count_smaller > count_max) {
            count_max = count_smaller;
        }
        return count_max;
    }
</script>
</body>
</html>